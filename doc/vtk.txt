VTK - Visualization Toolkit:

-hybrid wrapper facility -> flexible -> template
-OOP
-data members protected or private: access via Set, Get.
Many of these methods created by inserting macros in the class header file.
For example:

vtkSetMacro(Tolerance,double);
vtkGetMacro(Tolerance,double);
become:
virtual void SetTolerance(double);
virtual double GetTolerance();

Macro for data members controlling debugging, managing reference counting
-One of the strengths of VTK is its relatively simplistic means of representing and managing data:

- various data arrays of particular types vtkFloatArray
- Data arrays are subclasses of the vtkDataArray abstract class 
meaning that generic virtual methods can be used to simplify coding
- However, for higher performance static, templated functions are used which switch based on type
- templates are not visible in the public class API
- employ the PIMPL design pattern to hide the complexities of a template implementation 
from the user or application developer
- thus, we are mostly free of the complexities of data type selection

PIMPL = private implementation - pointer to the implementation:
-design a class which is binary compatible, when building an API
-encapsulate the real implementation from the API (Hide the private part of the class)
-a pointer to an object has always the same size
-Lesser header dependencies => because most header now only needs to be in the *.cpp
-Faster compilation times
- only the source file needs to be rebuilt, but not the header, and every file that includes it


API class has two parts:
-API-methods class
-Pimpl idiom class (a private  pointer to the instance) which holds the real implementation

#include <memory>
 
class Fridge
{
public:
   Fridge();
   ~Fridge();
   void coolDown();
private:
   class FridgeImpl;
   std::unique_ptr<FridgeImpl> impl_;
};

#include "Engine.h"
#include "Fridge.h"
 
class FridgeImpl
{
public:
   void coolDown()
   {
      /* ... */
   }
private:
   Engine engine_;
};
 
Fridge::Fridge() : impl_(new FridgeImpl) {}
Fridge::~Fridge() = default;



-VTK uses reference counting for memory management 
-ability to represent complex forms of data, subclasses of vtkDataObject

- the pipeline architecture consists of three basic classes of objects: 
-objects to represent data (vtkDataObjects)
-objects to process, transform, filter or map data objects from one form into another (vtkAlgorithm)
-objects to execute a pipeline (vtkExecutive) which controls a connected graph of interleaved data and process objects 

-the algorithms treat their inputs as immutable, algorithms only read their input in order to produce their output
example: 

vtkFileReader *reader = vtkFileReader::New();
reader->SetFileName("exampleFile.exo");
reader->Read();

ViewInterpolation *verp = ViewInterpolation::New();
verp->SetInputConnection(reader->GetOutputPort());

-after a VTK source or filter executes, its output is cached by the pipeline in order to avoid unnecessary executions in the future
-if a step in the pipeline is modified, all the steps after it should be executed again as its cache is not valid.

some methods:
public:
    static vtkProgressCommand *New() { return new vtkProgressCommand; }
	virtual void Execute()

-Subdirectories:
Common	core VTK classes
Filtering	classes used to manage pipeline dataflow
Rendering	rendering, picking, image viewing, and interaction
Imaging	imaging pipeline
IO	VTK input and output

-classes:
vtkImageClass that under the hood treats data arrays of pixel data. 